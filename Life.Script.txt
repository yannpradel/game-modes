/**
 *	Life Chacalou Mode
 */
 #Extends "Modes/Nadeo/Trackmania/Base/TrackmaniaRoundsBase.Script.txt"

 #Const	CompatibleMapTypes	"TrackMania\\TM_Race,TM_Race"
 #Const	Version							"1.0.0+2023-06-21"
 #Const	ScriptName					"Modes/TrackMania/TM_Knockout_Online.Script.txt"
 
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
 // Librarie
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
 #Include "TextLib" as TL
 #Include "MathLib" as ML
 #Include "Libs/Nadeo/CMGame/Utils/Semver.Script.txt" as Semver
 #Include "Libs/Nadeo/Trackmania/Modes/Knockout/StateManager.Script.txt" as StateMgr
 #Include "Libs/Nadeo/Trackmania/MainMenu/Constants.Script.txt" as MenuConsts
 #Include "Libs/Nadeo/TMGame/Utils/Tracking.Script.txt" as Tracking
 #Include "Libs/Nadeo/Trackmania/Modes/Knockout/UIModules/KnockoutInfo_Server.Script.txt" as UIModules_KnockoutInfo
 #Include "Libs/Nadeo/Trackmania/Modes/TimeAttack/UIModules/BestRaceViewer_Server.Script.txt" as UIModules_BestRaceViewer
 #Include "Libs/Nadeo/Trackmania/Modes/Knockout/UIModules/KnockedOutPlayers_Server.Script.txt" as UIModules_KnockedOutPlayers
 #Include "Libs/Nadeo/Trackmania/Modes/Knockout/UIModules/KnockoutReward_Server.Script.txt" as UIModules_KnockoutReward
 #Include "Libs/Nadeo/TMGame/Modes/Base/UIModules/PauseMenuOnline_Server.Script.txt" as UIModules_PauseMenu_Online
 #Include "Libs/Nadeo/TMGame/Modes/Base/UIModules/Checkpoint_Server.Script.txt" as UIModules_Checkpoint

#Include "ColorLib" as CL
 
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
 // Settings
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
 #Setting S_FinishTimeout 30 as _("Finish timeout")
 #Setting S_RoundsPerMap 4 as _("Number of rounds per track") //
 #Setting S_WarmUpNb 2 as _("Number of warm up")
 #Setting S_WarmUpDuration 2 as _("Duration of one warm up")
 #Setting S_WarmUpTimeout -1 as _("Warm up timeout")
 #Setting S_ChatTime 6
 #Setting S_EnableJoinLeaveNotifications False
 //L16N [Knockout] Setting for the KO mode, for exemple if the setting is "4,16,16" it means : "4 players eliminated per round until 16 players are left (16 is written twice, so two extra players are eliminated), then 2 players eliminated per round until 4 players are left (one extra player), then 1 player eliminated per round (default)".
 #Setting S_EliminatedPlayersNbRanks "4,16" as _("Nb of players above which one extra elim. /round")
 #Setting S_RoundsWithoutElimination 0 as _("Rounds without elimination")
 #Setting S_EarlyEndMatchCallback True as "<hidden>"
 #Setting S_MatchPosition -1 as "<hidden>" // Use to display player's final rank in CotD
 
 /* About S_EliminatedPlayersNbRanks
  * Example : "8,16"
  * 1 to 8 players -> 1 elimination per round
  * 9 to 16 players -> 2 eliminations per round
  * 17 or more players -> 3 eliminations per round
  *
  * Example : "8,16,16"
  * 1 to 8 players -> 1 eliminations per round
  * 9 to 16 players -> 2 eliminations per round
  * 17 or more players -> 4 eliminations per round
  *
  * Example : "0,8"
  * 1 to 8 players -> 2 eliminations per round
  * 9 or more players -> 3 eliminations per round
  *
  * Example : ""
  * 1 or more players -> 1 elimination per round
  */
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
 // Constants
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
 #Const C_ModeName "Knockout"
 #Const C_Life "Life.Knockout"
 //L16N [Knockout] Description of the mode
 #Const Description _("$zIn $<$t$6F9Knockout$> mode, the goal is to be the last player standing. \n\nYou play a series of races as in Round mode. $<$t$6F9At the end of each race, the last players are eliminated$>!\n\nThe winner is the player who eliminates all of their opponents.")
 
 #Const C_HudModulePath "" //< Path to the hud module
 #Const C_ManiaAppUrl "file://Media/ManiaApps/Nadeo/Trackmania/Modes/Knockout.Script.txt" //< Url of the mania app
 #Const C_FakeUsersNb 0
 
 #Const C_Callback_Elimination "Trackmania.Knockout.Elimination"
 
 // [Knockout] Time remaining before the first round begins (in seconds). %1 is a marker to apply typography. %2 is a digit. e.g. "Next round in 3s"
 #Const C_Text_NextRoundTimer _("%1Next round in %2s")
 #Const C_Text_Loser _("%1 %2lost a life")
 
 #Const C_UploadRecord True
 #Const C_DisplayRecordGhost False
 #Const C_DisplayRecordMedal False
 #Const C_CelebrateRecordGhost True
 #Const C_CelebrateRecordMedal True
 
 #Struct K_MatchInfo {
	 Boolean RegistrationClosed;
	 Integer[Text] PlayerRanks; // from 1 to ParticipantsNb, 0 means still alive, -1 means player never played but mode tried to eliminate them
	 Integer[Text] PlayerLifes; // 0 to 4 lifes
	 Integer[Text] PlayerPoints;
	 Integer[Text] PlayerMapPoints;
	 Integer KOPlayersNb;
	 Integer ParticipantsNb;
	 Integer RoundNeededNb;
	 Text[] RoundWinner;
 }
 
 #Struct K_Callback_Elimination {
	 Text[] accountids;
 }
 
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
 // Extends
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
 ***Match_LogVersions***
 ***
 Log::RegisterScript(ScriptName, Version);
 Log::RegisterScript(Semver::ScriptName, Semver::Version);
 Log::RegisterScript(ModeUtils::ScriptName, ModeUtils::Version);
 Log::RegisterScript(StateMgr::ScriptName, StateMgr::Version);
 ***
 
 ***Match_LoadLibraries***
 ***
 // Not used for now but can be useful for players
 XmlRpc::RegisterCallback(C_Callback_Elimination, """
 * Name: {{{C_Callback_Elimination}}}
 * Type: CallbackArray
 * Description: Callback sent at the end of each round with the accountid of eliminated players.
 * Data:
	 - Version >=2.0.0:
	 ```
	 [
		 "{
			 "accountids": [
				 {
					 "45b9cf1e-3c97-4753-ac63-ac61b48b4bb7"
				 }
			 ]
		 }"
	 ]
	 ```
 """);
 
 StateMgr::Load();
 ***
 
 ***Match_UnloadLibraries***
 ***
 StateMgr::Unload();
 
 XmlRpc::UnregisterCallback(C_Callback_Elimination);
 ***
 
 ***Match_Settings***
 ***
 MB_Settings_UseDefaultHud = (C_HudModulePath == "");
 MB_Settings_UseDefaultPodiumSequence = False;
 ***
 
 ***Match_Rules***
 ***
 ModeInfo::SetName(C_ModeName);
 ModeInfo::SetType(ModeInfo::C_Type_FreeForAll);
 ModeInfo::SetRules(Description);
 ModeInfo::SetStatusMessage("");
 ***
 
 ***Match_LoadHud***
 ***
 if (C_HudModulePath != "") Hud_Load(C_HudModulePath);
 ***
 
 ***Match_AfterLoadHud***
 ***
 ClientManiaAppUrl = C_ManiaAppUrl;
 Race::SortScores(Race::C_Sort_TotalPoints);
 UIModules_TimeGap::SetTimeGapMode(UIModules_TimeGap::C_TimeGapMode_CurRace);
 UIModules_PauseMenu_Online::SetHelp(Description);
 UIModules_Checkpoint::SetVisibilityTimeDiff(False);
 UIModules_Checkpoint::SetRankMode(UIModules_Checkpoint::C_RankMode_CurrentRace);

 SetML();
 ***
 
 ***Match_Yield***
 ***
 foreach (Event in PendingEvents) {
	 switch (Event.Type) {
		 // Initialize players when they join the server
		 case CSmModeEvent::EType::OnPlayerAdded: {
			 StateMgr::InitializePlayer(Event.Player);
			 CarRank::InitializePlayer(Event.Player);
		 }
	 }
 }
 
 // Manage XmlRpc events
 foreach (Event in XmlRpc.PendingEvents) {
	 if (Event.Type == CXmlRpcEvent::EType::CallbackArray) {
		 if (Event.ParamArray1 == "Club.Match.Start") { //@TODO @QG
			 declare Boolean Match_SkipWarmup for This = False;
			 Match_SkipWarmup = True;
		 } else if (Event.ParamArray1 == "Club.Match.Completed") { //@TODO @QG
			 declare Boolean Match_SkipWarmup for This = False;
			 Match_SkipWarmup = False;
		 }
	 }
 }
 
 StateMgr::Yield();
 ***
 
 ***Match_StartServer***
 ***
 // Initialize mode
 Clans::SetClansNb(0);
 Scores::SaveInScore(Scores::C_Points_Match);
 StateMgr::ForcePlayersStates([StateMgr::C_State_Waiting]);
 WarmUp::SetAvailability(True);
 
 Race::SetupRecord(
	 MenuConsts::C_ScopeType_Season,
	 MenuConsts::C_ScopeType_PersonalBest,
	 MenuConsts::C_GameMode_Knockout,
	 "",
	 C_UploadRecord,
	 C_DisplayRecordGhost,
	 C_DisplayRecordMedal,
	 C_CelebrateRecordGhost,
	 C_CelebrateRecordMedal
 );
 Race::UseAutomaticDossardColor(False);
 ***
 
 ***Match_InitMatch***
 ***
 declare Integer Match_CurrentRoundNb;
 declare Boolean Match_MatchIsOver;
 declare Text[] Match_WinnersLogins;
 declare Text[] Match_WinnersAccountIds;
 declare Boolean Match_SkipWarmup for This = False; // Must survive CServerPlugin.RestartMap()
 ***
 
 ***Match_StartMatch***
 ***
 Match_CurrentRoundNb = 0;
 Match_WinnersLogins = [];
 Match_WinnersAccountIds = [];
 declare K_MatchInfo Server_MatchInfo for This = K_MatchInfo {};
 Server_MatchInfo = K_MatchInfo {};
 
 OpenNewRegistrations();
 foreach(Player in Players) {
	 if (Player != Null) RegisterPlayer(Player);
 }
 UpdateCustomRanking();
 ***
 
 ***Match_InitMap***
 ***
 declare Boolean Map_DisplayCustom321Go;
 
 UpdateScoresTableFooter(Match_CurrentRoundNb, GetTotalRoundNb(Match_CurrentRoundNb, GetAlivePlayers()));
 UpdateCustomRanking();
 UIModules_KnockoutInfo::UpdateLiveRanking();
 UIModules_ScoresTable::SetScoreMode(UIModules_ScoresTable::C_Mode_PrevTime);
 ***
 
 ***Match_StartMap***
 ***
 Map_DisplayCustom321Go = True;
 
 // Add bot when necessary
 Users_SetNbFakeUsers(C_FakeUsersNb, 0);
 
 CarRank::Reset();
 
 // Warm up
 Race::SortScores(Race::C_Sort_BestRaceTime);
 UIModules_ScoresTable::SetCustomRanks([]);
 UIModules_ScoresTable::DisplayOnly([]);
 UIModules_ScoresTable::SetCustomPoints([]);
 UpdateCustomRanking();
 if (!Match_SkipWarmup) { // Warmup only before daily match starts
	 MB_WarmUp(S_WarmUpNb, S_WarmUpDuration * 1000, S_WarmUpTimeout * 1000);
 }
 

 ***
 
 ***Match_InitRound***
 ***
 declare Text[] Round_EliminatedPlayers = []; // accountids
 declare Integer Round_EliminatedPlayersNb;
 declare Boolean NeedInfoDisplayUpdate;
 ***
 
 ***Rounds_CanSpawn***
 ***
 // Register new players while registration are open
 if (RegistrationsAreOpen()) {
	 foreach(Player in Players) {
		 if (!PlayerIsRegistered(Player.User.WebServicesUserId)) RegisterPlayer(Player);
	 }
 }
 
 Match_CurrentRoundNb += 1;
 declare Integer AlivePlayersNb = GetAlivePlayers();
 Round_EliminatedPlayersNb = GetEliminationsNb(AlivePlayersNb, Match_CurrentRoundNb);
 if (Round_EliminatedPlayersNb <= 0) {
	 CarRank::ResetRanksColors();
 } else {
	 CarRank::SetRanksColors([
		 1 => Race::C_DossardColor_Default,
		 AlivePlayersNb - Round_EliminatedPlayersNb + 1 => <0.7, 0., 0.>
	 ]);
 }
 
 UpdateKnockoutInfoDisplay(Match_CurrentRoundNb, Round_EliminatedPlayersNb, GetAlivePlayers());
 
 declare ObjectiveMessage = "";
 if (Round_EliminatedPlayersNb > 1) {
	 //L16N [Knockout] Announce the number of players that will be eliminated at the end of the round. %1 will be replaced by a number greater than 1. eg: "2 players will be eliminated".
	 ObjectiveMessage = TL::Compose(_("%1 players will lose a life"), "$t$i$fff"^TL::ToText(Round_EliminatedPlayersNb));
 } else if (Round_EliminatedPlayersNb == 1){
	 //L16N [Knockout] Announce the number of players that will be eliminated at the end of the round. %1 will be replaced by the digit 1. eg: "1 player will be eliminated".
	 ObjectiveMessage = TL::Compose(_("%1 player will lose a life"), "$t$i$fff"^TL::ToText(Round_EliminatedPlayersNb));
 } else {
	 //L16N [Knockout] Announce the number of players that will be eliminated at the end of the round. %1 will be replaced by a marker for Typography
	 ObjectiveMessage = TL::Compose(_("%1No life loss this round"), "$t$i$fff");
 }
 UIModules_BigMessage::SetMessage(ObjectiveMessage, 3000);
 UIModules_BigMessage::SetOffset(<0., -40.>);
 
 if (Map_DisplayCustom321Go) {
	 UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::Default;
	 UIManager.UIAll.BigMessageSoundVariant = 0;
	 MB_Sleep(1000);
	 UIManager.UIAll.BigMessage = TL::Compose(C_Text_NextRoundTimer, "$i$t", "3");
	 MB_Sleep(1000);
	 UIManager.UIAll.BigMessage = TL::Compose(C_Text_NextRoundTimer, "$i$t", "2");
	 MB_Sleep(1000);
	 UIManager.UIAll.BigMessage = TL::Compose(C_Text_NextRoundTimer, "$i$t", "1");
	 MB_Sleep(1000);
	 UIManager.UIAll.BigMessage = "";
	 StartTime = Now + Race::C_SpawnDuration;
 }
 
 // Reset spawn permissions for players and spectators according to Rounds rules
 foreach (Score in Scores) {
	 if (Score == Null) continue;
	 declare ModeRounds_CanSpawn for Score = True;
	 declare Knockout_SpawnPermissionRequested for Score = False;
	 Knockout_SpawnPermissionRequested = False;
	 if (MM_IsMatchServer()) {
		 declare Player <=> GetPlayer(Score.User.WebServicesUserId);
		 ModeRounds_CanSpawn = MM_PlayerIsAllowedToPlay(Player);
	 } else {
		 ModeRounds_CanSpawn = True;
	 }
 }
 // Check spawn permissions for players according to KO rules
 foreach (Player in Players) {
	 if (
		 Player != Null &&
		 Player.Score != Null
	 ) {
		 declare Knockout_SpawnPermissionRequested for Player.Score = False;
		 if (!Knockout_SpawnPermissionRequested) {
			 Knockout_SpawnPermissionRequested = True;
			 RequestSpawnPermission(Player);
			 NeedInfoDisplayUpdate = True;
		 }
	 }
 }
 
 if (NeedInfoDisplayUpdate) {
	 UpdateKnockoutInfoDisplay(Match_CurrentRoundNb, Round_EliminatedPlayersNb, GetAlivePlayers());
	 NeedInfoDisplayUpdate = False;
 }
 ***
 
 ***Match_StartRound***
 ***
 // Update UI
 UIModules_BestRaceViewer::SetPrevDisplay(False);

 declare Text NewPointsRep = "";

	NewPointsRep = TL::ToText(Players.count);
	for (I, 1, GetAlivePlayers()-1) {
		NewPointsRep = NewPointsRep ^ "," ^ TL::ToText(Players.count-I);
	}

	declare ConvertedNewPointsRep = PointsRepartition::ConvertPointsRepartition(NewPointsRep);
	PointsRepartition::SetPointsRepartition(ConvertedNewPointsRep);
 
 foreach (Score in Scores) {
	 SetFinishedRace(Score, False);
	 TagDNF(Score, False);
	 TagAlive(Score, PlayerIsAlive(Score.User.WebServicesUserId));
 }
 UpdateKnockoutInfoDisplay(Match_CurrentRoundNb, Round_EliminatedPlayersNb, GetAlivePlayers());
 NeedInfoDisplayUpdate = False;
 
 StateMgr::ForcePlayersStates([StateMgr::C_State_Playing]);
 ***
 
 ***Rounds_PlayerSpawned***
 ***
 CarRank::ThrottleUpdate(CarRank::C_SortCriteria_CurrentRace);
 ***
 
 ***Rounds_PlayLoopSpawnPlayers***
 ***
 // Spawn allowed players
 foreach (Player in Players) {
	 if (
		 Player != Null &&
		 Player.Score != Null
	 ) {
		 declare Knockout_SpawnPermissionRequested for Player.Score = False;
		 if (!Knockout_SpawnPermissionRequested) {
			 Knockout_SpawnPermissionRequested = True;
			 RequestSpawnPermission(Player);
			 NeedInfoDisplayUpdate = True;
		 }
		 declare ModeRounds_CanSpawn for Player.Score = True;
		 if (
			 Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned &&
			 MB_RoundIsRunning() &&
			 ModeRounds_CanSpawn &&
			 Race::IsReadyToStart(Player)
		 ) {
			 Race::Start(Player, StartTime);
			 ModeRounds_CanSpawn = False;
			 TagDNF(Player.Score, False);
			 +++Rounds_PlayerSpawned+++
		 }
	 }
 }
 if (NeedInfoDisplayUpdate) {
	 UpdateKnockoutInfoDisplay(Match_CurrentRoundNb, Round_EliminatedPlayersNb, GetAlivePlayers());
	 NeedInfoDisplayUpdate = False;
 }
 
 ***
 
 ***Match_PlayLoop***
 ***
 foreach (Event in PendingEvents) {
	 if (Event.Type == CSmModeEvent::EType::OnPlayerAdded) {
		 if (Event.Player != Null) {
			 UIModules_BestRaceViewer::SetPrevDisplay(Event.Player, False);
		 }
	 }
 }
 
 // Manage race events
 declare RacePendingEvents = Race::GetPendingEvents();
 foreach (Event in RacePendingEvents) {
	 Race::ValidEvent(Event);
 
	 // Waypoint
	 if (Event.Type == Events::C_Type_Waypoint) {
		 CarRank::ThrottleUpdate(CarRank::C_SortCriteria_CurrentRace);
		 if (Event.Player != Null) {
			 if (Event.IsEndRace) {
				 Scores::UpdatePlayerPrevRace(Event.Player);
				 declare BetterRace = Scores::UpdatePlayerBestRaceIfBetter(Event.Player);
				 declare BetterLap = Scores::UpdatePlayerBestLapIfBetter(Event.Player);
 
				 // Start the countdown if it's the first player to finish
				 if (EndTime <= 0) {
					 EndTime = GetFinishTimeout();
				 }
 
				 SetFinishedRace(Event.Player.Score, True);
				 UIModules_BestRaceViewer::SetPrevDisplay(Event.Player, True);
				 UpdateCustomRanking();
			 }
			 if (Event.IsEndLap) {
				 declare Better = Scores::UpdatePlayerBestLapIfBetter(Event.Player);
			 }
		 }
		 UIModules_KnockoutInfo::UpdateLiveRanking();
	 }
	 // GiveUp
	 if (Event.Type == Events::C_Type_GiveUp) {
		 if (Event.Player != Null && Event.Player.Score != Null) {
			 TagDNF(Event.Player.Score, True);
		 }
		 UIModules_KnockoutInfo::UpdateLiveRanking();
	 }
 }
 
 
 // Manage mode events
 foreach (Event in PendingEvents) {
	 if (Event.HasBeenPassed || Event.HasBeenDiscarded) continue;
	 Events::Invalid(Event);
 }
 ***
 
 ***Match_EndRound***
 ***
 Race::StopSkipOutroAll();
 EndTime = -1;
 StateMgr::ForcePlayersStates([StateMgr::C_State_Waiting]);
 CarRank::Update(CarRank::C_SortCriteria_CurrentRace);

 
 if (Semver::Compare(XmlRpc::GetApiVersion(), ">=", "2.1.1")) {
	 Scores::XmlRpc_SendScores(Scores::C_Section_PreEndRound, "");
 }
 
 if (Round_ForceEndRound || Round_SkipPauseRound) {
	 // Cancel points
	 foreach (Score in Scores) {
		 Scores::SetPlayerRoundPoints(Score, 0);
	 }
	 // Do not launch the forced end round sequence after a pause
	 if (!Round_SkipPauseRound) {
		 ForcedEndRoundSequence();
	 }
	 MB_SetValidRound(False);
 } else {
	declare Integer RealNbKo = 0;
	 // Eliminate players that did not finish in time
	 declare Ident[] EliminatedPlayersScoresIds = []; // Score.Id
	 declare Ident[] ReversedEliminatedPlayersScoresIds = []; // Score.Id
	 if (Match_CurrentRoundNb > S_RoundsWithoutElimination) {
		 // Close registrations. Players can join the game any time during no elimination rounds
		 if (RegistrationsAreOpen()) CloseRegistrations();
 
		 // Eliminate last players
		 Race::SortScores(Race::C_Sort_PrevRaceTime);
		 declare EliminationsNb = GetEliminationsNb(GetAlivePlayers(), Match_CurrentRoundNb);

		 if (Scores.count > 0) {
			 for (I, 0, Scores.count-1) {
				 declare Score <=> Scores[Scores.count-1 - I];
				 if (Score != Null) {
					 if (PlayerIsAlive(Score.User.WebServicesUserId)) {
						 if (!GetFinishedRace(Score)) {
							 ReversedEliminatedPlayersScoresIds.add(Score.Id);
							 EliminationsNb -= 1;
							 TagDNF(Score, True);
						 } else if (EliminationsNb > 0) {
							ReversedEliminatedPlayersScoresIds.add(Score.Id);
							 EliminationsNb -= 1;
						 }
					 }
				 }
			 }

			 foreach (ScoreId in ReversedEliminatedPlayersScoresIds) {
				 EliminatedPlayersScoresIds.add(ScoreId);
			 }
		 }
		 EliminatedPlayersScoresIds = EliminatePlayers(EliminatedPlayersScoresIds); // cette fonction doit rendre le nombre d'elmiiné I guess
		 foreach (ScoreId in EliminatedPlayersScoresIds) {
			if (
				Scores.existskey(ScoreId) &&
				Scores[ScoreId] != Null
			) {
				Round_EliminatedPlayers.add(Scores[ScoreId].User.WebServicesUserId);
			}
		}
	 }
 
	 // Check if match is over
	 if (MatchIsOver(Match_CurrentRoundNb)) {
		 Match_MatchIsOver = True;
		 declare K_MatchInfo Server_MatchInfo for This = K_MatchInfo {};
		 Match_WinnersAccountIds = [];
		 Match_WinnersLogins = [];
		 foreach (AccountId => Status in Server_MatchInfo.PlayerRanks) {
			 if (Status == 0) Match_WinnersAccountIds.add(AccountId);
		 }
		 if (Match_WinnersAccountIds.count > 0) {
			 declare Ident[] LeaderScoresIds;
			 foreach (Score in Scores) {
				 if (
					 Score != Null &&
					 Match_WinnersAccountIds.exists(Score.User.WebServicesUserId)
				 ) {
					 LeaderScoresIds.add(Score.Id);
					 Match_WinnersLogins.add(Score.User.Login);
				 }
			 }
			 EliminatePlayers(LeaderScoresIds); // Only one player will be considered as winner
		 }
	 }
 
	 // Send Trophies, uses Round_EliminatedPlayers array
	 +++Match_EndRound_AfterComputeScores+++
 
	 UIModules_KnockoutInfo::UpdateLiveRanking();
	 UpdateCustomRanking();
	 UpdateScoresTableFooter(Match_CurrentRoundNb, GetTotalRoundNb(Match_CurrentRoundNb, GetAlivePlayers()));

	 // heart anim for players
	 declare netwrite Integer Net_DisplayHeartAnimation for Teams[0] = 0;
	 Net_DisplayHeartAnimation += 1;
	 //MB_Sleep(500);

	 declare ObjectiveMessage = "";
	 foreach (Key => Loser in ReversedEliminatedPlayersScoresIds) {
		log("Eliminated: " ^ Loser);
		declare Player = GetPlayer(Scores[Loser].User.Login);
		 if (Player != Null) {
			ObjectiveMessage = ObjectiveMessage ^ Player.User.Name;
			if (Key == ReversedEliminatedPlayersScoresIds.count - 1) {
				ObjectiveMessage = ObjectiveMessage ^ " ";
			} else if (Key == ReversedEliminatedPlayersScoresIds.count - 2) {
				ObjectiveMessage = ObjectiveMessage ^ " and ";
			} else {
				ObjectiveMessage = ObjectiveMessage ^ ", ";
			}
			//log(""^ObjectiveMessage);
		 }
	 }	

	 ObjectiveMessage = ObjectiveMessage ^ "lost a life";

	 UIModules_BigMessage::SetMessage(ObjectiveMessage, 5000);
	 UIModules_BigMessage::SetOffset(<0., -40.>);
	 MB_Sleep(1800);
	 Net_DisplayHeartAnimation += 1;
	 MB_Sleep(1800);
	 Net_DisplayHeartAnimation += 1;
	 MB_Sleep(1400);

 
	 if (EliminatedPlayersScoresIds.count > 0) {
		UIModules_KnockedOutPlayers::DisplayContent(True);
		UIModules_KnockedOutPlayers::DisplayEliminatedPlayer(Round_EliminatedPlayers, GetPlayerRanks(Round_EliminatedPlayers));
		declare PagesToShow = Round_EliminatedPlayers.count/4;
		if (Round_EliminatedPlayers.count%4 != 0) PagesToShow += 1;
		MB_Sleep(ML::Max(1100 + 350*Round_EliminatedPlayers.count + 1600*PagesToShow + 250, 6000 + 250));
		UIModules_KnockedOutPlayers::DisplayEliminatedPlayer([], []);
		UIModules_KnockedOutPlayers::DisplayContent(False);
		declare K_Callback_Elimination Callback_Elimination;
		foreach(AccountId in Round_EliminatedPlayers) {
			Callback_Elimination.accountids.add(AccountId);
		}
		XmlRpc::SendCallback(C_Callback_Elimination, [Callback_Elimination.tojson()]);
		foreach (ScoreId in EliminatedPlayersScoresIds) {
			if (
				Scores.existskey(ScoreId) &&
				Scores[ScoreId] != Null
			) {
				declare Player = GetPlayer(Scores[ScoreId].User.Login);
				if (Player != Null) {
					UIModules_KnockoutReward::SetPlayerEliminated(Player, True);
					UIModules_KnockoutReward::SendResult(Player);
				}
			}
		}
		foreach (Login in Match_WinnersLogins) {
			declare Player = GetPlayer(Login);
			if (Player != Null) {
				UIModules_KnockoutReward::SetPlayerEliminated(Player, True); // Winner
				UIModules_KnockoutReward::SendResult(Player);
			}
		}
	}

	Race::SortScores(Race::C_Sort_PrevRaceTime);
	SetRoundWinner(Scores[0].User.WebServicesUserId);
	

 
	 if (MapIsOver(Match_CurrentRoundNb)) MB_StopMap();
 }
 ***
 
 ***Match_EndMap***
 ***

 UpdateCustomRanking();

 if (MatchIsOver(Match_CurrentRoundNb)) {
	 MB_StopMatch();
 } else {
	 MB_Sleep(2500);
 }
 
 if (!MB_MapIsRunning() && MB_MatchIsRunning()) MB_SkipPodiumSequence();
 
 Scores::SetPlayerWinner(Scores[0]);
 ***
 
 ***Match_PodiumSequence***
 ***
 if (!MB_Private_SkipPodiumSequence) {
	 ModeUtils::PlaySound(CUIConfig::EUISound::EndRound, 0);
 
	 declare WinnerScore <=> Scores::GetPlayerWinner();
	 if (WinnerScore != Null) {
		 UIModules_BigMessage::SetMessage(_("$<%1$> wins the match!"), WinnerScore.User.WebServicesUserId);
	 } else {
		 UIModules_BigMessage::SetMessage(_("|Match|Draw"));
	 }
 
	 // Send the EndMatch callback sooner to speed up the API update
	 if (S_EarlyEndMatchCallback) {
		 Scores::EndMatch();
		 Scores::XmlRpc_SendScores(Scores::C_Section_EndMatch, ""); // send "Trackmania.Scores"
		 Log::Log("Send early end match callback");
	 }
 
	 declare PrevUISequence = UIManager.UIAll.UISequence;
	 UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;
	 MB_Private_Sleep(10000);
	 UIModules_BigMessage::SetMessage("");
	 UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
	 MB_Private_Sleep((S_ChatTime*1000));
	 UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
	 UIManager.UIAll.UISequence = PrevUISequence;
 }
 ***
 
 ***Match_AfterPodiumSequence***
 ***
 if (!MB_Private_SkipPodiumSequence) {
	 // End Match and delete data
	 declare K_MatchInfo Server_MatchInfo for This = K_MatchInfo {};
	 Server_MatchInfo = K_MatchInfo {};
	 foreach (Score in Scores) {
		 if (Score == Null) continue;
		 TagDNF(Score, False);
		 TagAlive(Score, False);
		 UIModules_KnockoutReward::ResetResult(Score);
	 }
	 Scores::Clear();
	 UpdateScoresTableFooter(Match_CurrentRoundNb, GetTotalRoundNb(Match_CurrentRoundNb, GetAlivePlayers()));
	 UpdateCustomRanking();
	 UIModules_KnockoutInfo::UpdateLiveRanking();
	 foreach (Player in AllPlayers) {
		 if (Player != Null) {
			 UIModules_KnockoutReward::SetPlayerEliminated(Player, False);
		 }
	 }
 }
 ***
 
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
 // Functions
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //

 Void SetML() {

    declare Text Manialink = """
    <manialink version="3" name="{{{C_Life}}}">

	<frame id="frame-global" pos="0 0">
			<quad id="bg" pos="0 0" size="20 20" halign="center" valign="center" z-index="1"/>
			<quad id="quad-heart" size="32 18" z-index="7" halign="center" valign="center" pos="118 21"/>
			<quad id="quad-heart-left" size="32 18" z-index="7" halign="center" valign="center" pos="-120 21"/>
			<quad id="quad-future-winner" size="53.5 5" z-index="1" pos="-160 -60" opacity="0.5" bgcolor="000"/>
			<label text="  Potential Life Winner: " textfont="GameFontExtraBold" z-index="2" pos="-156 -55.5" textsize="1.5" halign="left" textprefix="$i$t"/>
			<label id="label-future-winner" text="---" textfont="GameFontExtraBold" z-index="2" pos="-134 -61" textsize="1.5" halign="center" textprefix="$i$t"/>
	</frame>
    
        <script><!--

            #Const C_AttachId {{{dump(C_Life)}}}

			declare CAudioSource G_Sound_Heart_Broken;


			Void displayHeartAnimation() {
				declare CMlFrame Frame_Global <=> (Page.GetFirstChild("frame-global") as CMlFrame);
				declare CMlQuad Quad_Heart <=> (Frame_Global.GetFirstChild("quad-heart") as CMlQuad);
				declare CMlQuad Quad_Heart_Left <=> (Frame_Global.GetFirstChild("quad-heart-left") as CMlQuad);
				Quad_Heart.Opacity = 1.;
				Quad_Heart_Left.Opacity = 1.;

				declare Text VideoUrl = "https://cdn.discordapp.com/attachments/922936935155105853/1236767293892202516/outpt_1.webm?ex=663934cc&is=6637e34c&hm=1b40f0f1495f93f5f5cb7c1f858f9042e0891ea77d6cad3d4e545253485a1fdc&";
				if (VideoUrl != "") {
					declare CVideo CloudsVideo <=> Video.CreateVideo(VideoUrl, False, True);

					// Play the confetti video behind the pop-up
					if (CloudsVideo != Null && CloudsVideo.Id != NullId && Video.Videos.existskey(CloudsVideo.Id)) {
						Quad_Heart.Image = CloudsVideo.Image;
						Quad_Heart_Left.Image = CloudsVideo.Image;
						Video.Videos[CloudsVideo.Id].Stop();
						Video.Videos[CloudsVideo.Id].Play();
					}
				}
				AnimMgr.Flush(Quad_Heart);
				AnimMgr.Flush(Quad_Heart_Left);
				AnimMgr.Add(Quad_Heart, "<a opacity=0/>",Now + 2200, 2300, CAnimManager::EAnimManagerEasing::ExpOut);
				AnimMgr.Add(Quad_Heart_Left, "<a opacity=0/>",Now + 2200, 2300, CAnimManager::EAnimManagerEasing::ExpOut);
				//G_Sound_Heart_Broken.Play();
			}

			Void updatePlayerLife(Text _PotentialWinner) {
				declare CMlFrame Frame_Global <=> (Page.GetFirstChild("frame-global") as CMlFrame);
				declare CMlLabel Label_Future_Winner <=> (Frame_Global.GetFirstChild("label-future-winner") as CMlLabel);
				declare CMlQuad Quad_Future_Winner <=> (Frame_Global.GetFirstChild("quad-future-winner") as CMlQuad);

				if (_PotentialWinner != "") {
					Label_Future_Winner.Value = _PotentialWinner;
				} else {
					Label_Future_Winner.Value = "";
				}
			}
            
            main() {

				G_Sound_Heart_Broken = Audio.CreateSound("file://Media/Manialinks/Nadeo/Trackmania/Ingame/Sound/RaceCheckPoint_Experimental.wav", 6.0, False, False, False);
                log("Init " ^ C_AttachId);

                declare CMlFrame Frame_Global <=> (Page.GetFirstChild("frame-global") as CMlFrame);

                wait(InputPlayer != Null);

                Frame_Global.Visible = True;
				declare netread Integer Net_DisplayHeartAnimation for Teams[0] = 0;
				declare netread Integer Net_Update_Heart for Teams[0] = 0;
				declare netread Text Net_PotentialWinner for Teams[0] = "";

				declare Integer Last_HeartAnim_Update = Net_DisplayHeartAnimation;
				declare Integer Last_HeartUpdate = Net_Update_Heart;

                while (True) {
                    yield;
					if (Net_DisplayHeartAnimation != Last_HeartAnim_Update) {
						displayHeartAnimation();
						Last_HeartAnim_Update = Net_DisplayHeartAnimation;
					}
					if (Net_Update_Heart != Last_HeartUpdate) {
						updatePlayerLife(Net_PotentialWinner);
						Last_HeartUpdate = Net_Update_Heart;
					}
				}
            }
        
        --></script>
    </manialink>
    """;

    Layers::Create(C_Life, Manialink);
    Layers::SetType(C_Life, CUILayer::EUILayerType::Normal);
    Layers::Attach(C_Life);
}
 /** Whether the player is registered or not
  *
  *@return										True if the player is registered
  *													False Otherwise
  */
 Boolean PlayerIsRegistered(Text _AccountId) {
	 if (_AccountId == "") return False;
	 declare K_MatchInfo Server_MatchInfo for This;
	 return Server_MatchInfo.PlayerRanks.existskey(_AccountId);
 }
 
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
 /** Whether the player has been eliminated or not
  *
  *@return										True if the player has been eliminated
  *													False Otherwise
  */
 Boolean PlayerIsAlive(Text _AccountId) {
	 if (_AccountId == "") return False;
	 declare K_MatchInfo Server_MatchInfo for This;
	 //log("PlayerIsMaybeAlive: "^TL::ToText(Server_MatchInfo.PlayerLifes[_AccountId]));
	 return (
		 PlayerIsRegistered(_AccountId) &&
		 Server_MatchInfo.PlayerRanks[_AccountId] == 0 &&
		 Server_MatchInfo.PlayerLifes[_AccountId] > 0
	 );
 }
 
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
 /** Tag a score as finished curr race or not
  *
  *	@param														_Score
  *	@param														_IsAlive
  */
 Void TagAlive(CSmScore _Score, Boolean _IsAlive) {
	 if (_Score == Null) return;
	 declare netwrite Boolean Net_Knockout_PlayerIsAlive for _Score = False;
	 Net_Knockout_PlayerIsAlive = _IsAlive;
 }
 
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
 /** Tag a score as DNF
  *
  *	@param														_Score
  *	@param														_DNF
  */
 Void TagDNF(CSmScore _Score, Boolean _DNF) {
	 if (_Score == Null) return;
	 declare netwrite Boolean Net_Knockout_DNF for _Score = False;
	 Net_Knockout_DNF = _DNF;
 }
 
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
 /** Number of players still playing
  *
  *	@return														Number of players still playing
  */
 Integer GetAlivePlayers() {
	 declare K_MatchInfo Server_MatchInfo for This = K_MatchInfo {};
	 return (Server_MatchInfo.ParticipantsNb - Server_MatchInfo.KOPlayersNb);
 }
 
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
 /** Init player at the begining of the match
  *
  *	@param	_Player							Player to init
  */
 Void RegisterPlayer(CSmPlayer _Player) {
	 if (_Player == Null) return;
	 declare K_MatchInfo Server_MatchInfo for This = K_MatchInfo {};
	 if (Server_MatchInfo.RegistrationClosed) return;
	 if (
		 !Server_MatchInfo.PlayerRanks.existskey(_Player.User.WebServicesUserId) &&
		 !Server_MatchInfo.RegistrationClosed
	 ) {
		 Server_MatchInfo.PlayerRanks[_Player.User.WebServicesUserId] = 0;
		 Server_MatchInfo.PlayerLifes[_Player.User.WebServicesUserId] = 3;
		 Server_MatchInfo.PlayerPoints[_Player.User.WebServicesUserId] = 0;
		 Server_MatchInfo.PlayerMapPoints[_Player.User.WebServicesUserId] = 0;
		 Server_MatchInfo.ParticipantsNb += 1;
		 UIModules_KnockoutInfo::SetAlivePlayersNb(GetAlivePlayers());
		 TagAlive(_Player.Score, True);
	 }
 }
 
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
 /** Players can join the match after this function is called
  *
  */
 Void OpenNewRegistrations() {
	 declare K_MatchInfo Server_MatchInfo for This;
	 Server_MatchInfo = K_MatchInfo {
		 RegistrationClosed = False,
		 PlayerRanks = [],
		 PlayerLifes = [],
		 PlayerPoints = [],
		 PlayerMapPoints = [],
		 RoundNeededNb = 2,
		 RoundWinner = [],
		 KOPlayersNb = 0,
		 ParticipantsNb = 0
	 };
	 foreach (Score in Scores) {
		 UIModules_KnockoutReward::ResetResult(Score);
	 }
	 foreach (Player in AllPlayers) {
		 if (Player != Null) {
			 UIModules_KnockoutReward::SetPlayerEliminated(Player, False);
		 }
	 }
 }
 
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
 /** Whether the player can join match or not
  *
  *@return										True if the player can join
  *													False Otherwise
  */
 Boolean RegistrationsAreOpen() {
	 declare K_MatchInfo Server_MatchInfo for This;
	 return !Server_MatchInfo.RegistrationClosed;
 }
 
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
 /** Players can't join the match anymore after this function is called
  *
  */
 Void CloseRegistrations() {
	 declare K_MatchInfo Server_MatchInfo for This = K_MatchInfo {};
	 Server_MatchInfo.RegistrationClosed = True;
 }
 
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
 /** Eliminate players and assign them their final ranks
  * according to the _ScoreIds list order. 1st player is the best ranked
  *
  *	@param	_ScoreIds							Score Ids of Players to Eliminate
  */
 Ident[] EliminatePlayers(Ident[] _ScoreIds) {
	declare Ident[] EliminatedPlayersScoresIds = []; // Score.Id
	 if (_ScoreIds.count == 0) return [];
	 declare K_MatchInfo Server_MatchInfo for This = K_MatchInfo {};
	 if (!Server_MatchInfo.RegistrationClosed) return []; // Cannot eliminate players if registrations are still open
	 foreach (ScoreId in _ScoreIds) {
		 if (Scores.existskey(ScoreId)) {
			 declare CSmScore Score <=> Scores[ScoreId];
			 declare Text AccountId = Score.User.WebServicesUserId;
			 if (!PlayerIsRegistered(AccountId)) {
				 Server_MatchInfo.PlayerRanks[AccountId] = -1;
				 UIModules_KnockoutReward::SaveRank(Score, -1);
				 UIModules_KnockoutReward::SaveCupRank(Score, -1, -1);
			 } else if (PlayerIsAlive(AccountId)) {
				 if (Server_MatchInfo.PlayerLifes[AccountId] > 0) {
					 Server_MatchInfo.PlayerLifes[AccountId] -= 1;
					 if (Server_MatchInfo.PlayerLifes[AccountId] == 0) {
						 EliminatedPlayersScoresIds.add(ScoreId);
						 Server_MatchInfo.KOPlayersNb += 1;
						 declare Integer Rank = Server_MatchInfo.ParticipantsNb - Server_MatchInfo.KOPlayersNb + 1;
						 Server_MatchInfo.PlayerRanks[AccountId] = Rank;
						 UIModules_KnockoutReward::SaveRank(Score, Rank);
						 UIModules_KnockoutReward::SaveCupRank(Score, S_MatchPosition, Rank);
						 Tracking::SendPlayerMatchResult(UIManager, Score.User, Rank, Rank == 1);
						 TagAlive(Score, False);
					 }
				 }
			 }
		 }
	 }
	 return EliminatedPlayersScoresIds;
 }
 
 Integer[] GetEliminationsMilestones() {
	 declare Text_Milestones = TL::Split(",", S_EliminatedPlayersNbRanks);
	 declare Integer[] Milestones = [1];
	 foreach (Text_Milestone in Text_Milestones) {
		 declare Milestone = TL::ToInteger(Text_Milestone);
		 if (Milestone > 0) Milestones.add(Milestone);
		 else if (Milestone == 0) Milestones.add(1);
	 }
	 return Milestones;
 }
 
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
 /** Players Nb at which Emilinations Nb per round decreases
  *
  *	@param	_AlivePlayers							Number of players still playing
  *	@return														Players Nb of the milestone
  */
 Integer GetNextMilestone(Integer _AlivePlayers) {
	 if (_AlivePlayers <= 0) return 0;
	 declare Integer[] Milestones = GetEliminationsMilestones();
 
	 declare NextMilestone = 0;
	 foreach (Milestone in Milestones) {
		 if (Milestone < _AlivePlayers) {
			 NextMilestone = Milestone;
		 }
	 }
	 return NextMilestone;
 }
 
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
 /** Number of players to eliminate this round
  *
  *	@param	_AlivePlayers							Number of players still playing
  *	@return														Number of eliminations this round
  */
 Integer GetEliminationsNb(Integer _AlivePlayers, Integer _RoundNb) {
	 if (_AlivePlayers <= 1) return 0;
	 if (_RoundNb <= S_RoundsWithoutElimination) return 0;
	 declare Milestones = GetEliminationsMilestones();
	 declare RoundMinEliminations = Milestones.count + 1;
	 foreach (Index => Milestone in Milestones) {
		 if (Milestone < _AlivePlayers) {
			 RoundMinEliminations = Index + 1;
		 }
	 }
	 return ML::Min(RoundMinEliminations, _AlivePlayers-1);
 }
 
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
 /** Estimated number of rounds
  *
  *	@return												Estimated number of rounds
  */
 Integer GetTotalRoundNb(Integer _CurrentRoundNb, Integer _AlivePlayers) {
	 declare RoundsWithEliminationsLeft = 0;
	 declare AlivePlayers = _AlivePlayers;
	 declare Milestones = GetEliminationsMilestones();
	 for (Index, 0, Milestones.count-1) {
		 declare ReverseIndex = Milestones.count-1 - Index;
		 declare Milestone = Milestones[ReverseIndex];
		 if (AlivePlayers > Milestone && AlivePlayers > 1) {
			 declare ElimNbPerRound = ReverseIndex + 1;
			 declare TotalElimNb = AlivePlayers - Milestone;
			 if (TotalElimNb % ElimNbPerRound > 0) TotalElimNb += ElimNbPerRound - TotalElimNb % ElimNbPerRound;
			 RoundsWithEliminationsLeft += TotalElimNb / ElimNbPerRound;
			 AlivePlayers -= TotalElimNb;
		 }
	 }
 
	 return ML::Max(_CurrentRoundNb, S_RoundsWithoutElimination + 1) + ML::Max(0, RoundsWithEliminationsLeft);
 }
 
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
 /** Whether the player finished the race or not
  *
  *	@param	_Score								Player's score
  *	@param	_HasFinished					True if player finished race
  */
 Void SetFinishedRace(CSmScore _Score, Boolean _HasFinished) {
	 declare Knockout_FinishedRace for _Score = False;
	 Knockout_FinishedRace = _HasFinished;
 }
 
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
 /** Whether the player finished the race or not
  *
  *	@param	_Score								Player's score
  *	@return												True if player finished race
  */
 Boolean GetFinishedRace(CSmScore _Score) {
	 declare Knockout_FinishedRace for _Score = False;
	 return Knockout_FinishedRace;
 }
 
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
 /** Player rank in match
  *
  *	@param	_AccountIds								Account Ids
  *	@return												Ranks in same order
  */
 Integer[] GetPlayerRanks(Text[] _AccountIds) {
	 declare K_MatchInfo Server_MatchInfo for This = K_MatchInfo {};
	 declare Integer[] Result = [];
	 foreach (AccountId in _AccountIds) {
		 if (Server_MatchInfo.PlayerRanks.existskey(AccountId)) {
			 Result.add(Server_MatchInfo.PlayerRanks[AccountId]);
		 } else {
			 Result.add(-2);
		 }
	 }
	 return Result;
 }
 
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
 /** Whether the player can be spwaned or not, according to KO rules only
  *
  *@param _Player						The Player
  *@return										True if the player can be spwaned
  *													False Otherwise
  */
 Boolean RequestSpawnPermission(CSmPlayer _Player) {
	 if (_Player == Null || _Player.Score == Null) return False;
	 declare ModeRounds_CanSpawn for _Player.Score = True;
	 if (
		 RegistrationsAreOpen() &&
		 !PlayerIsRegistered(_Player.User.WebServicesUserId)
	 ) {
		 RegisterPlayer(_Player);
	 }
	 ModeRounds_CanSpawn = (
		 ModeRounds_CanSpawn &&
		 PlayerIsAlive(_Player.User.WebServicesUserId)
	 );
	 return ModeRounds_CanSpawn;
 }
 
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
 /** Update the Scores Table with hidden custom points
  *
  */
 Void UpdateCustomRanking() {
	declare netwrite Integer Net_Update_Heart for Teams[0] = 0;
	declare netwrite Text Net_PotentialWinner for Teams[0] = "";
	 declare Text[] AccountIdsToDisplay = [];
	 declare Text[Text] CustomRanks = [];
	 declare Text[][Text] CustomPoints = [];
	 declare Integer[Text] CustomTimes = [];
	 declare Text[Text] CustomNames = [];
	 declare K_MatchInfo Server_MatchInfo for This = K_MatchInfo {};
	 Race::SortScores(Race::C_Sort_PrevRaceTime);
	 declare Integer ColorizeHeart = 0;
	 Net_PotentialWinner = "---";
	 if (Server_MatchInfo.RoundWinner.count > 0) {
		 if (Server_MatchInfo.RoundNeededNb == 2) {
			 ColorizeHeart = 1;
			 Net_PotentialWinner = Server_MatchInfo.RoundWinner[0] ^ "   " ^ Server_MatchInfo.RoundNeededNb-1 ^ "/" ^ Server_MatchInfo.RoundNeededNb;
		 }
		 if (Server_MatchInfo.RoundNeededNb == 3 && Server_MatchInfo.RoundWinner.count > 1) {
			if (Server_MatchInfo.RoundWinner[0] == Server_MatchInfo.RoundWinner[1]) {
				ColorizeHeart = 1;
				Net_PotentialWinner = Server_MatchInfo.RoundWinner[0] ^ "   " ^ Server_MatchInfo.RoundNeededNb-1 ^ "/" ^ Server_MatchInfo.RoundNeededNb;
			} else Net_PotentialWinner = Server_MatchInfo.RoundWinner[0] ^ "   " ^ Server_MatchInfo.RoundNeededNb-2 ^ "/" ^ Server_MatchInfo.RoundNeededNb;
		 } else if(Server_MatchInfo.RoundNeededNb == 3 && Server_MatchInfo.RoundWinner.count > 0) Net_PotentialWinner = Server_MatchInfo.RoundWinner[0] ^ "   " ^ Server_MatchInfo.RoundNeededNb-2 ^ "/" ^ Server_MatchInfo.RoundNeededNb;
	 }
	 Net_Update_Heart += 1;
	 foreach (Index => Score in Scores) {
		 if (Score == Null) continue;
		 if (PlayerIsRegistered(Score.User.WebServicesUserId)) {
			 AccountIdsToDisplay.add(Score.User.WebServicesUserId);
 
			 if (PlayerIsAlive(Score.User.WebServicesUserId)) {
				declare Text PlayerName = "$<"^Score.User.Name^"$>";
				 Scores::SetPlayerMatchPoints(Score, Server_MatchInfo.PlayerLifes[Score.User.WebServicesUserId]);
				 CustomRanks[Score.User.WebServicesUserId] = " - ";

				 if (Server_MatchInfo.PlayerLifes[Score.User.WebServicesUserId] == 4) {
					CustomPoints[Score.User.WebServicesUserId] = ["   ", "f00"];
					//check if roundWinner index exists
					if (Server_MatchInfo.RoundWinner.count > 0) {
						if (Server_MatchInfo.RoundWinner[0] == Score.User.Name && ColorizeHeart == 1) {
							CustomPoints[Score.User.WebServicesUserId] = ["   ", "0ff"];
						}
					}
				 }
				 if (Server_MatchInfo.PlayerLifes[Score.User.WebServicesUserId] == 3) {
					CustomPoints[Score.User.WebServicesUserId] = ["   $999", "f00"];
					if (Server_MatchInfo.RoundWinner.count > 0) {
						if (Server_MatchInfo.RoundWinner[0] == Score.User.Name && ColorizeHeart == 1) {
							CustomPoints[Score.User.WebServicesUserId] = ["   $999", "0ff"];
						}
					}
				 }

				 if (Server_MatchInfo.PlayerLifes[Score.User.WebServicesUserId] == 2) {
					CustomPoints[Score.User.WebServicesUserId] = ["  $999 ", "f00"];
					if (Server_MatchInfo.RoundWinner.count > 0) {
						if (Server_MatchInfo.RoundWinner[0] == Score.User.Name && ColorizeHeart == 1) {
							CustomPoints[Score.User.WebServicesUserId] = ["  $999 ", "0ff"];
						}
					}
				 }

				 if (Server_MatchInfo.PlayerLifes[Score.User.WebServicesUserId] == 1) {
					CustomPoints[Score.User.WebServicesUserId] = [" $999  ", "f00"];
					if (Server_MatchInfo.RoundWinner.count > 0) {
						if (Server_MatchInfo.RoundWinner[0] == Score.User.Name && ColorizeHeart == 1) {
							CustomPoints[Score.User.WebServicesUserId] = [" $999  ", "0ff"];
						}
					}
				 }
				 
				 if (Score.User.ClubTag == "") {
					CustomNames[Score.User.WebServicesUserId] = PlayerName;
					for (I,0,15-TL::Length(Score.User.Name)) {
						CustomNames[Score.User.WebServicesUserId] = CustomNames[Score.User.WebServicesUserId] ^ "  ";
					}
					CustomNames[Score.User.WebServicesUserId] = CustomNames[Score.User.WebServicesUserId] ^ "| " ^ Server_MatchInfo.PlayerMapPoints[Score.User.WebServicesUserId] ^ "$888    (map points)";
				 }
				else {
					CustomNames[Score.User.WebServicesUserId] = "[" ^ Score.User.ClubTag ^ "$g] " ^ PlayerName;
					for (I,0,15-TL::Length(Score.User.Name)-TL::Length(Score.User.ClubTag)+1) {
						CustomNames[Score.User.WebServicesUserId] = CustomNames[Score.User.WebServicesUserId] ^ "  ";
					}
					CustomNames[Score.User.WebServicesUserId] = CustomNames[Score.User.WebServicesUserId] ^ "| " ^ Server_MatchInfo.PlayerMapPoints[Score.User.WebServicesUserId] ^ "$888    (map points)";
				}
				//log("nb character " ^  10-TL::Length(Score.User.Name) ^ "Words" ^ Score.User.Name);
				 if (!GetFinishedRace(Score)) {
					 CustomTimes[Score.User.WebServicesUserId] = 0; //@ prev race is updated automatically at the moment (22/10/20) so we need to use this
				 }
			 } else {
				//log("Player is not alive");
				 declare FinalRank = -1;
				 if (Server_MatchInfo.PlayerRanks.existskey(Score.User.WebServicesUserId)) {
					 FinalRank = Server_MatchInfo.PlayerRanks[Score.User.WebServicesUserId];
					 Scores::SetPlayerMatchPoints(Score, Server_MatchInfo.PlayerLifes[Score.User.WebServicesUserId] - FinalRank); //mettre - nb elimité ? jsp
					 CustomRanks[Score.User.WebServicesUserId] = ""^FinalRank;
				 } else {
					 Scores::SetPlayerMatchPoints(Score, 0);
					 CustomRanks[Score.User.WebServicesUserId] = "-";
				 }
				 //L16N [Knockout] Do not translate if K.O. is understandable. This is the player status.
				 CustomPoints[Score.User.WebServicesUserId] = [_("|Status|K.O."), "f00"];
				 if (FinalRank == 1) {
					 //L16N [Knockout]
					 CustomPoints[Score.User.WebServicesUserId] = [_("|Status|Winner"), "0f0"];
				 }
			 }
		 }
	 }
	 Race::SortScores(Race::C_Sort_TotalPoints);
	 UIModules_ScoresTable::SetCustomRanks(CustomRanks);
	 UIModules_ScoresTable::DisplayOnly(AccountIdsToDisplay); // Display only registered players
	 UIModules_ScoresTable::SetCustomPoints(CustomPoints);
	 UIModules_ScoresTable::SetCustomTimes(CustomTimes);
	 //UIModules_ScoresTable::SetCustomNames(CustomNames);
 }
 
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
 /** Get the time left to the players to finish the round after the first player
  *
  *	@return 		The time left in ms
  */
 Integer GetFinishTimeout() {
	 declare FinishTimeout = 0;
 
	 if (S_FinishTimeout >= 0) {
		 FinishTimeout = S_FinishTimeout * 1000;
	 } else {
		 FinishTimeout = 5000;
		 if (Map.TMObjective_IsLapRace && Race::GetLapsNb() > 0 && Map.TMObjective_NbLaps > 0) {
			 FinishTimeout += ((Map.TMObjective_AuthorTime / Map.TMObjective_NbLaps) * Race::GetLapsNb()) / 6;
		 } else {
			 FinishTimeout += Map.TMObjective_AuthorTime / 6;
		 }
	 }
 
	 return Now + FinishTimeout;
 }
 
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
 /** Check if we should go to the next match
  *
  *	@param _RoundNb		Current round number
  *	@return						True if it is the case, false otherwise
  */
 Boolean MatchIsOver(Integer _RoundNb) {
	 if (_RoundNb < S_RoundsWithoutElimination || RegistrationsAreOpen() || GetAlivePlayers() > 1) return False;
 
	 return True;
 }
 
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
 /** Check if we should go to the next map
  *
  *	@param _RoundNb		Current round number
  *	@return						True if it is the case, false otherwise
  */
 Boolean MapIsOver(Integer _RoundNb) {
	 if (MatchIsOver(_RoundNb)) return True;
	 if (S_RoundsPerMap > 0 && MB_GetRoundCount() >= S_RoundsPerMap) return True; //< There is a rounds limit and it is reached
 
	 return False;
 }
 
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
 /** Update the scores table footer text
  *
  *	@param	_TotalRounds							The estimated number of rounds
  *	@param	_AlivePlayers							The number of Alive Players
  *	@param	_RoundKOs									The number players to eliminate this round
  *	@param	_Milestone								Next number of players at which one less player is eliminated per round
  */
 Void UpdateScoresTableFooter(Integer _CurrentRoundNb, Integer _TotalRoundsNb) {
	 //L16N [Knockout]
	 declare Message = "";
	 if (MatchIsOver(_CurrentRoundNb)) {
		 Message = _("Match is over");
	 } else {
		 declare AlivePlayersNb = GetAlivePlayers();
		 declare Milestone = GetNextMilestone(AlivePlayersNb);
		 declare CurrentRound = _CurrentRoundNb;
		 if (CurrentRound == 0) CurrentRound = 1;
		 declare TotalRoundsNb = _TotalRoundsNb;
		 if (CurrentRound > TotalRoundsNb) TotalRoundsNb = CurrentRound;
		 declare EliminationsNb = GetEliminationsNb(AlivePlayersNb, _CurrentRoundNb);
		 if (EliminationsNb == 0 || Milestone <= 1) {
			 if (EliminationsNb <= 0) {
				 if (AlivePlayersNb <= 1) {
					 //L16N [Knockout] Scores table footer. %1 is the number of current round. %2 the total number of rounds. %3 the number of players playing the round, and is always 1 OR LESS "No K.O. this round" means that no players will be eliminated, KO stands for "Knockouts". \n is a new line.
					 Message = TL::Compose(_("Round %1/%2\n%3 Player racing\nNo K.O. this round"), ""^MB_GetRoundCount(), ""^S_RoundsPerMap, ""^AlivePlayersNb);
				 } else {
					 //L16N [Knockout] Scores table footer. %1 is the number of current round. %2 the total number of rounds. %3 the number of players playing the round, and is always 2 OR MORE "No K.O. this round" means that no players will be eliminated, KO stands for "Knockouts". \n is a new line.
					 Message = TL::Compose(_("Round %1/%2\n%3 Players racing\nNo K.O. this round"), ""^MB_GetRoundCount(), ""^S_RoundsPerMap, ""^AlivePlayersNb);
				 }
			 } else if (EliminationsNb == 1) {
				 if (AlivePlayersNb <= 1) {
					 //L16N [Knockout] Scores table footer. %1 is the number of current round. %2 the total number of rounds. %3 the number of players playing the round, and is always 1 OR LESS. "1 K.O. per round" is the number of eliminated players, KO stands for "Knockouts". \n is a new line.
					 Message = TL::Compose(_("Round %1/%2\n%3 Player\n1 K.O. per round"), ""^MB_GetRoundCount(), ""^S_RoundsPerMap, ""^AlivePlayersNb);
				 } else {
					 //L16N [Knockout] Scores table footer. %1 is the number of current round. %2 the total number of rounds. %3 the number of players playing the round, and is always 2 OR MORE. "1 K.O. per round" is the number of eliminated players, KO stands for "Knockouts". \n is a new line.
					 Message = TL::Compose(_("Round %1/%2\n%3 Players\n1 K.O. per round"), ""^MB_GetRoundCount(), ""^S_RoundsPerMap, ""^AlivePlayersNb);
				 }
			 } else {
				 if (AlivePlayersNb <= 1) {
					 //L16N [Knockout] Scores table footer. %1 is the number of current round. %2 the total number of rounds. %3 the number of players playing the round, and is always 1 OR LESS. %4 the number of eliminated players, stands for "Knockouts", always greater than 1. \n is a new line.
					 Message = TL::Compose(_("Round %1/%2\n%3 Player\n%4 K.O. per round"), ""^MB_GetRoundCount(), ""^S_RoundsPerMap, ""^AlivePlayersNb, ""^EliminationsNb);
				 } else {
					 //L16N [Knockout] Scores table footer. %1 is the number of current round. %2 the total number of rounds. %3 the number of players playing the round, and is always 2 OR MORE. %4 the number of eliminated players, stands for "Knockouts", always greater than 1. \n is a new line.
					 Message = TL::Compose(_("Round %1/%2\n%3 Players\n%4 K.O. per round"), ""^MB_GetRoundCount(), ""^S_RoundsPerMap, ""^AlivePlayersNb, ""^EliminationsNb);
				 }
			 }
 
		 } else {
			 //L16N [Knockout] Scores table footer. %1 is the number of current round. %2 the total number of rounds. %3 the number of players playing the round (assumed greater than 1). %4 the number of eliminated players, stands for "Knockouts", greater than 1. %5 is the next number of players at which one less player is eliminated per round. \n is a new line.
			 Message = TL::Compose(_("Round %1/%2, %3 Players\n%4 K.O. per round until %5 players"), ""^MB_GetRoundCount(), ""^S_RoundsPerMap, ""^AlivePlayersNb, ""^EliminationsNb, ""^Milestone);
		 }
	 }
 
	 UIModules_ScoresTable::SetFooterInfo(Message);
 }
 
 Void UpdateKnockoutInfoDisplay(Integer _CurrentRoundNb, Integer _Round_EliminatedPlayersNb, Integer _AlivePlayers) {
	 declare TotalRoundsNb = GetTotalRoundNb(_CurrentRoundNb, _AlivePlayers);
	 UIModules_KnockoutInfo::SetAlivePlayersNb(_AlivePlayers);
	 UIModules_KnockoutInfo::SetMapRoundNb(ML::Min(S_RoundsPerMap, MB_GetRoundCount()), ML::Min(S_RoundsPerMap, TotalRoundsNb));
	 UIModules_KnockoutInfo::SetRoundNb(ML::Min(S_RoundsPerMap, MB_GetRoundCount()), ML::Min(S_RoundsPerMap, TotalRoundsNb));
	 UIModules_KnockoutInfo::SetKOsNumber(_Round_EliminatedPlayersNb, GetNextMilestone(_AlivePlayers));
	 UIModules_KnockoutInfo::UpdateLiveRanking();
	 UpdateCustomRanking();
	 UpdateScoresTableFooter(_CurrentRoundNb, TotalRoundsNb);
 }

 /**
 * Gets the score for a user with given login.
 * Returns null if there is no score for the given login.
 */
 CSmScore GetScore(Text Login) {
	foreach(Score in Scores) {
		if(Score.User.Login == Login) return Score;
	}
	return Null;
}


Void AddLife(Text _Player) {
	declare K_MatchInfo Server_MatchInfo for This = K_MatchInfo {};
	if (!Server_MatchInfo.PlayerLifes.existskey(_Player)) {
		log("Player " ^ _Player ^ " is not registered");
		return;
	}


	if(Server_MatchInfo.PlayerLifes[_Player] < 4) {
		Server_MatchInfo.PlayerLifes[_Player] += 1;
	}
}

Void SetRoundWinner(Text _RoundWinnerID) {
	declare K_MatchInfo Server_MatchInfo for This = K_MatchInfo {};
	declare Player <=> ModeUtils::GetPlayerFromAccountId(_RoundWinnerID);
	Server_MatchInfo.RoundWinner.addfirst(Player.User.Name);

	if (GetAlivePlayers() < 6) {
		Server_MatchInfo.RoundNeededNb = 3;
	}
	else {
		Server_MatchInfo.RoundNeededNb = 2;
	}

	log("RoundWinner: " ^ Server_MatchInfo.RoundWinner);

	//2 rounds needed, need at least 1 winner or 3 rounds needed, need at least 2 winners
	if ((Server_MatchInfo.RoundWinner.count > 0 && Server_MatchInfo.RoundNeededNb == 2) || (Server_MatchInfo.RoundWinner.count > 1 && Server_MatchInfo.RoundNeededNb == 3)) {
		//mettre le coeur en jaune


		declare Text LastWinner = Server_MatchInfo.RoundWinner[Server_MatchInfo.RoundNeededNb - 2];
		declare Boolean AllSame = True;
		if ((Server_MatchInfo.RoundWinner.count == 1 && Server_MatchInfo.RoundNeededNb == 2) || (Server_MatchInfo.RoundWinner.count == 2 && Server_MatchInfo.RoundNeededNb == 3)) AllSame = False;
		foreach (Key => RoundWinner in Server_MatchInfo.RoundWinner) {
			if (Key > Server_MatchInfo.RoundNeededNb - 1) break;
			if (RoundWinner != LastWinner) {
				AllSame = False;
				break;
			}
		}
		if (AllSame) {
			log("All same");
			declare Text ObjectiveMessage = "";
			if (Player != Null)  {

				ObjectiveMessage = Player.User.Name ^ " won a life!";

				UIModules_BigMessage::SetMessage(ObjectiveMessage, 5000);
				UIModules_BigMessage::SetOffset(<0., -40.>);
				MB_Sleep(5000);
				AddLife(_RoundWinnerID);
				Server_MatchInfo.RoundWinner = [];
			}
		}
	}
}







